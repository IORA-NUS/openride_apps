from abc import ABC, abstractclassmethod, abstractmethod
import asyncio, json, logging, time, os

from datetime import datetime
from dateutil.relativedelta import relativedelta
from apps.messenger_service import Messenger

from apps.config import orsim_settings, settings

class ORSimAgent(ABC):


    def __init__(self, unique_id, run_id, reference_time, scheduler_id, behavior):
        self.unique_id = unique_id
        self.run_id = run_id
        self.scheduler_id = scheduler_id
        self.reference_time = datetime.strptime(reference_time, '%Y%m%d%H%M%S') # datetime
        self.current_time = self.reference_time

        # Ideally behavior should be read from a datafile/db or in case of simulation, generated by the Model and passed in as attribute
        self.prev_time_step = 0
        self.current_time_step = 0
        self.elapsed_duration_steps = 0
        self.active = False


        self._shutdown = False
        self.behavior = behavior

        self.agent_credentials = {
            'email': f"{self.run_id}_{self.scheduler_id}_{unique_id}",
            'password': "secret_password",
        }

    def is_active(self):
        return self.active

    def on_receive_message(self, client, userdata, message):
        ''' '''
        start_time = time.time()
        try:
            # logging.info(f"{message.topic = }")
            if message.topic == f"{self.run_id}/{self.scheduler_id}/ORSimAgent":
                payload = json.loads(message.payload.decode('utf-8'))
                self.refresh(payload['time_step'])

                if payload.get('action') == 'init':
                    ''' NOTE This is unused block of code at the moment'''
                    # print(f"{self.unique_id} received {payload=}")
                    response_payload = {
                        'agent_id': self.unique_id,
                        'time_step': self.current_time_step,
                        'action': 'ready', # 'completed',
                    }
                elif payload.get('action') == 'step':
                    # self.refresh(payload['time_step'])
                    self.process_payload(payload)

                    response_payload = {
                        'agent_id': self.unique_id,
                        'time_step': self.current_time_step,
                        'action': 'completed' if self._shutdown==False else 'shutdown',
                    }
                elif payload.get('action') == 'shutdown':
                    ''' '''
                    self.shutdown()
                    response_payload = {
                        'agent_id': self.unique_id,
                        'time_step': self.current_time_step,
                        'action': 'shutdown',
                    }
            else:
                logging.warning(f'Unprocessed Message: {message.topic = }')
                response_payload = {
                    'agent_id': self.unique_id,
                    'time_step': self.current_time_step,
                    'action': 'unprocessed',
                }
        except Exception as e:
            response_payload = {
                'agent_id': self.unique_id,
                'time_step': self.current_time_step,
                'action': 'error',
                'details': str(e)
            }
            logging.exception(f"{self.unique_id} raised {str(e)}")

        self.agent_messenger.client.publish(f'{self.run_id}/{self.scheduler_id}/ORSimScheduler', json.dumps(response_payload))

        end_time = time.time()

        logging.info(f"Runtime for {self.unique_id} at {self.current_time_step}: {end_time - start_time:0.2f} secs ")

    @abstractmethod
    def process_payload(self, payload):
        pass

    def start_listening(self):

        self.agent_messenger = Messenger(self.agent_credentials, f"{self.run_id}/{self.scheduler_id}/ORSimAgent", self.on_receive_message)

        if settings['CONCURRENCY_STRATEGY'] == 'ASYNCIO':
            logging.info(f'Agent {self.unique_id} is Listening for Messages')
            loop = asyncio.get_event_loop()
            try:
                loop.run_forever()
            except KeyboardInterrupt:
                pass
            finally:
                loop.close()
        elif settings['CONCURRENCY_STRATEGY'] == 'EVENTLET':
            import eventlet

            def run_forever():
                while True:
                    eventlet.sleep(0.1)
                    if self._shutdown == True:
                        break

            eventlet.spawn(run_forever)

        # Once agent is setup and listening, send the ready message
        response_payload = {
            'agent_id': self.unique_id,
            # 'time_step': self.current_time_step,
            'action': 'ready',
        }
        self.agent_messenger.client.publish(f'{self.run_id}/{self.scheduler_id}/ORSimScheduler', json.dumps(response_payload))

    def stop_listening(self):
        self.agent_messenger.disconnect()

    def get_current_time_str(self):
        return datetime.strftime(self.current_time, "%a, %d %b %Y %H:%M:%S GMT")

    def refresh(self, time_step):

        self.prev_time_step = self.current_time_step
        self.current_time_step = time_step
        self.elapsed_duration_steps = self.current_time_step - self.prev_time_step

        self.current_time = self.reference_time + relativedelta(seconds = time_step * orsim_settings['SIM_STEP_SIZE'])

    def shutdown(self):
        logging.info(f'Shutting down {self.unique_id = }')
        self.logout()
        self.stop_listening()
        self.active = False
        self._shutdown = True

    @abstractmethod
    def logout(self):
        ''' process any logout processes needed in the agent.
        '''
        pass

    def get_transition_probability(self, condition, default):
        try:
            for rule in self.behavior.get('transition_prob'):
                if rule[0] == condition:
                    return rule[1]
        except: pass

        return default
