from abc import ABC, abstractclassmethod, abstractmethod
import asyncio, json, logging, time, os, traceback

from datetime import datetime
from dateutil.relativedelta import relativedelta
from apps.messenger_service import Messenger

from apps.config import orsim_settings, settings
from apps.utils import time_to_str, str_to_time

class ORSimAgent(ABC):


    def __init__(self, unique_id, run_id, reference_time, scheduler_id, behavior):
        self.unique_id = unique_id
        self.run_id = run_id
        self.scheduler_id = scheduler_id
        self.reference_time = datetime.strptime(reference_time, '%Y%m%d%H%M%S') # datetime
        self.current_time = self.reference_time
        self.next_event_time = self.reference_time # To be set by agent at every step_response

        # Ideally behavior should be read from a datafile/db or in case of simulation, generated by the Model and passed in as attribute
        self.prev_time_step = 0
        self.current_time_step = 0
        self.elapsed_duration_steps = 0
        self.active = False

        self._shutdown = False
        self.behavior = behavior

        self.agent_credentials = {
            'email': f"{self.run_id}_{self.scheduler_id}_{unique_id}",
            'password': "secret_password",
        }

        self.start_time = time.time()
        self.message_processing_active = False

    def is_active(self):
        return self.active

    def on_receive_message(self, client, userdata, message):
        ''' '''
        self.start_time = time.time()
        self.message_processing_active = True
        try:
            payload = json.loads(message.payload.decode('utf-8'))
            logging.debug(f"Agent {self.unique_id} received {payload.get('action')}")

            if message.topic == f"{self.run_id}/{self.scheduler_id}/ORSimAgent":
                self.bootstrap_step(payload['time_step'])

                if payload.get('action') == 'init':
                    ''' NOTE This is unused block of code at the moment'''
                    # print(f"{self.unique_id} received {payload=}")
                    response_payload = {
                        'agent_id': self.unique_id,
                        'time_step': self.current_time_step,
                        'action': 'ready', # 'completed',
                    }
                elif payload.get('action') == 'step':

                    self.process_payload(payload)

                    self.next_event_time = self.estimate_next_event_time()

                    response_payload = {
                        'agent_id': self.unique_id,
                        'time_step': self.current_time_step,
                        'action': 'completed' if self._shutdown==False else 'shutdown',
                    }
                elif payload.get('action') == 'shutdown':
                    ''' '''
                    self.shutdown()
                    response_payload = {
                        'agent_id': self.unique_id,
                        'time_step': self.current_time_step,
                        'action': 'shutdown',
                    }
            else:
                logging.warning(f'Unprocessed Message: {message.topic = }')
                response_payload = {
                    'agent_id': self.unique_id,
                    'time_step': self.current_time_step,
                    'action': 'unprocessed',
                }
        except Exception as e:
            response_payload = {
                'agent_id': self.unique_id,
                'time_step': self.current_time_step,
                'action': 'error',
                'details': traceback.format_exc() # str(e)
            }
            logging.exception(f"{self.unique_id} raised {str(e)}")

        self.agent_messenger.client.publish(f'{self.run_id}/{self.scheduler_id}/ORSimScheduler', json.dumps(response_payload))

        self.end_time = time.time()
        self.message_processing_active = False

        logging.info(f"Runtime for {self.unique_id} at {self.current_time_step}: {self.end_time - self.start_time:0.2f} secs ")

    @abstractmethod
    def process_payload(self, payload):
        pass

    def start_listening(self):

        self.agent_messenger = Messenger(self.agent_credentials, f"{self.run_id}/{self.scheduler_id}/ORSimAgent", self.on_receive_message)

        if settings['CONCURRENCY_STRATEGY'] == 'ASYNCIO':
            logging.info(f'Agent {self.unique_id} is Listening for Messages')
            loop = asyncio.get_event_loop()
            try:
                loop.run_forever()
            except KeyboardInterrupt:
                pass
            finally:
                loop.close()
        elif settings['CONCURRENCY_STRATEGY'] == 'EVENTLET':
            import eventlet

            def run_forever():
                while True:
                    eventlet.sleep(0.1)
                    self.handle_heartbeat_failure()
                    # logging.info(f"{self.unique_id} Heartbeat")
                    if self._shutdown == True:
                        break

            eventlet.spawn(run_forever)

        # Once agent is setup and listening, send the ready message
        response_payload = {
            'agent_id': self.unique_id,
            'time_step': -1,
            'action': 'ready',
        }
        self.agent_messenger.client.publish(f'{self.run_id}/{self.scheduler_id}/ORSimScheduler', json.dumps(response_payload))

    def stop_listening(self):
        self.agent_messenger.disconnect()

    def get_current_time_str(self):
        return time_to_str(self.current_time)

    # @classmethod
    # def time_to_str(cls, time_var):
    #     return datetime.strftime(time_var, "%a, %d %b %Y %H:%M:%S GMT")

    # @classmethod
    # def str_to_time(cls, time_str):
    #     return datetime.strptime(time_str, "%a, %d %b %Y %H:%M:%S GMT")

    def bootstrap_step(self, time_step):

        self.prev_time_step = self.current_time_step
        self.current_time_step = time_step
        self.elapsed_duration_steps = self.current_time_step - self.prev_time_step

        self.current_time = self.reference_time + relativedelta(seconds = time_step * orsim_settings['STEP_INTERVAL'])

    def shutdown(self):
        logging.info(f'Shutting down {self.unique_id = }')
        self.logout()
        self.stop_listening()
        self.active = False
        self._shutdown = True

    def handle_heartbeat_failure(self):
        if self.message_processing_active:
            now = time.time()
            threshold = orsim_settings['STEP_TIMEOUT']
            if (now - self.start_time) > threshold:
                logging.warning(f"Auto Shutdown Agent {self.unique_id}. Exceeded heartbeat threshold {threshold} sec")
                self.stop_listening()
                self.active = False
                self._shutdown = True

    @abstractmethod
    def estimate_next_event_time(self):
        pass

    @abstractmethod
    def logout(self):
        ''' process any logout processes needed in the agent.
        '''
        pass

    def get_transition_probability(self, condition, default):
        try:
            for rule in self.behavior.get('transition_prob'):
                if rule[0] == condition:
                    return rule[1]
        except: pass

        return default
