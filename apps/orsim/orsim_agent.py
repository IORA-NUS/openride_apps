from abc import ABC, abstractclassmethod, abstractmethod
import asyncio, json, logging

from datetime import datetime
from dateutil.relativedelta import relativedelta
from apps.messenger_service import Messenger
from apps.config import settings

class ORSimAgent(ABC):

    sim_settings = settings['SIM_SETTINGS']

    def __init__(self, unique_id, run_id, reference_time, scheduler_id, behavior):
        self.unique_id = unique_id
        self.run_id = run_id
        self.scheduler_id = scheduler_id
        self.reference_time = datetime.strptime(reference_time, '%Y%m%d%H%M%S') # datetime
        self.current_time = self.reference_time

        # Ideally behavior should be read from a datafile/db or in case of simulation, generated by the Model and passed in as attribute
        self.prev_time_step = 0
        self.current_time_step = 0
        self.elapsed_duration_steps = 0

        self._shutdown = False

        self.behavior = behavior

        # if behavior is not None:
        #     self.behavior = behavior
        # else:
        #     self.behavior = self.__class__.load_behavior(unique_id)

        self.agent_credentials = {
            'email': f"{self.run_id}_{self.scheduler_id}_{unique_id}",
            'password': "secret_password",
        }

        # self.agent_messenger = Messenger(run_id, self.agent_credentials, f"ORSimAgent_{self.unique_id}", self.on_receive_message)

    def on_receive_message(self, client, userdata, message):
        ''' '''
        # print(f'Agent {self.unique_id} received message:', message.payload.decode('utf-8'))
        # # payload = json.loads(message.payload.decode('utf-8'))

        # # if payload.get('action') == 'enter_market':
        # #     self.entering_market(payload.get('time_step'))
        # # elif payload.get('action') == 'step':
        # #     self.step(payload.get('time_step'))
        # # elif payload.get('action') == 'exit_market':
        # #     self.exiting_market()
        try:
            # logging.info(f"{message.topic = }")
            if message.topic == f"{self.run_id}/{self.scheduler_id}/ORSimAgent":
                payload = json.loads(message.payload.decode('utf-8'))

                if payload.get('action') == 'init':
                    ''' '''
                    # print(f"{self.unique_id} received {payload=}")
                    response_payload = {
                        'agent_id': self.unique_id,
                        'action': 'completed',
                    }
                elif payload.get('action') == 'step':
                    self.refresh(payload['time_step'])
                    self.process_payload(payload)

                    response_payload = {
                        'agent_id': self.unique_id,
                        'time_step': self.current_time_step,
                        'action': 'completed',
                    }
                elif payload.get('action') == 'kill':
                    ''' '''
                    self.shutdown()
            else:
                logging.warning(f'Unprocessed Message: {message.topic = }')
                response_payload = {
                    'agent_id': self.unique_id,
                    'time_step': self.current_time_step,
                    'action': 'unprocessed',
                }
        except Exception as e:
            response_payload = {
                'agent_id': self.unique_id,
                'action': 'error',
                'details': str(e)
            }
            logging.exception(str(e))

        self.agent_messenger.client.publish(f'{self.run_id}/{self.scheduler_id}/ORSimScheduler', json.dumps(response_payload))

    # @abstractclassmethod
    # def load_behavior(cls, unique_id):
    #     pass

    @abstractmethod
    def process_payload(self, payload):
        pass

    def start_listening(self):

        self.agent_messenger = Messenger(self.agent_credentials, f"{self.run_id}/{self.scheduler_id}/ORSimAgent", self.on_receive_message)

        async_strategy = 'eventlet'
        if settings['CONCURRENCY_STRATEGY'] == 'ASYNCIO':
            logging.info(f'Agent {self.unique_id} is Listening for Messages')
            loop = asyncio.get_event_loop()
            try:
                loop.run_forever()
            except KeyboardInterrupt:
                pass
            finally:
                loop.close()
        elif settings['CONCURRENCY_STRATEGY'] == 'EVENTLET':
            import eventlet

            def run_forever():
                while True:
                    eventlet.sleep(0.1)
                    if self._shutdown == True:
                        break

            eventlet.spawn(run_forever)

    def get_current_time_str(self):
        return datetime.strftime(self.current_time, "%a, %d %b %Y %H:%M:%S GMT")

    def refresh(self, time_step):

        self.prev_time_step = self.current_time_step
        self.current_time_step = time_step
        self.elapsed_duration_steps = self.current_time_step - self.prev_time_step

        self.current_time = self.reference_time + relativedelta(seconds = time_step * self.sim_settings['SIM_STEP_SIZE'])

    def shutdown(self):
        logging.info(f'Shutting down {self.unique_id = }')
        self._shutdown = True

    def get_transition_probability(self, condition, default):
        try:
            for rule in self.behavior.get('transition_prob'):
                if rule[0] == condition:
                    return rule[1]
        except: pass

        return default
