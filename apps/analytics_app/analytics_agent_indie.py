import os, sys, json
current_path = os.path.abspath('.')
parent_path = os.path.dirname(current_path)
sys.path.append(parent_path)

import logging
from apps.config import settings
from mesa import Agent
from .analytics_app import AnalyticsApp

from datetime import datetime
from dateutil.relativedelta import relativedelta

from apps.messenger_service import Messenger

from apps.orsim import ORSimAgent

class AnalyticsAgentIndie(ORSimAgent):
    ''' '''

    def __init__(self, unique_id, run_id, reference_time, scheduler_id, behavior):
        # # NOTE, model should include run_id and start_time
        # super().__init__(unique_id, model)
        super().__init__(unique_id, run_id, reference_time, scheduler_id, behavior)

        # self.unique_id = unique_id
        # self.run_id = run_id
        # self.reference_time = datetime.strptime(reference_time, '%Y%m%d%H%M%S') # datetime
        # self.current_time = self.reference_time

        # # Ideally behavior should be read from a datafile/db or in case of simulation, generated by the Model and passed in as attribute
        # self.prev_time_step = 0
        # self.current_time_step = 0
        # self.elapsed_duration_steps = 0

        # if behavior is not None:
        #     self.behavior = behavior
        # else:
        #     self.behavior = AnalyticsAgentIndie.load_behavior(unique_id)
        self.sim_settings = settings['SIM_SETTINGS']

        self.credentials = {
            'email': self.behavior.get('email'),
            'password': self.behavior.get('password'),
        }

        # self.analytics_app = AnalyticsApp(model.run_id, model.get_current_time_str(), self.credentials)
        self.analytics_app = AnalyticsApp(self.run_id, self.get_current_time_str(), self.credentials)

    #     self.agent_messenger = Messenger(run_id, self.credentials, f"sim_agent_{self.unique_id}", self.on_receive_message)

    def process_payload(self, payload):
        if payload.get('action') == 'step':
            self.step(payload.get('time_step'))

    # def process_message(self, client, userdata, message):
    #     ''' '''
    #     payload = json.loads(message.payload.decode('utf-8'))

    #     if payload.get('action') == 'step':
    #         self.step(payload.get('time_step'))


    # def on_receive_message(self, client, userdata, message):
    #     ''' '''
    #     payload = json.loads(message.payload.decode('utf-8'))

    #     if payload.get('action') == 'step':
    #         self.step(payload.get('time_step'))

    #     response_payload = {
    #         'agent_id': self.unique_id,
    #         'action': 'completed'
    #     }

    #     self.agent_messenger.client.publish(f'sim_agent/response', json.dumps(response_payload))

    # # def get_current_time_str(self):
    # #     return self.model.get_current_time_str()

    # @classmethod
    # def load_behavior(cls, unique_id, behavior=None):
    #     ''' '''
    #     if behavior is None:
    #         behavior = {
    #             'email': f'{unique_id}@test.com',
    #             'password': 'password',

    #         }

    #     return behavior


    def step(self, time_step):
        ''' '''
        # print('AnalyticsAgent.step')
        # self.refresh(time_step)

        # Publish Active trips using websocket Protocol
        if self.sim_settings['PUBLISH_REALTIME_DATA']:
            location_stream, route_stream = self.analytics_app.publish_active_trips(self.get_current_time_str())
            # print(publish_dict)

            if self.sim_settings['WRITE_WS_OUTPUT_TO_FILE']:
                current_dir = os.path.dirname(os.path.abspath(__file__))
                if not os.path.exists(f"{current_dir}/output/{self.run_id}"):
                    os.makedirs(f"{current_dir}/output/{self.run_id}")

                with open(f"{current_dir}/output/{self.run_id}/{self.current_time_step}.location_stream.json", 'w') as publish_file:
                    publish_file.write(json.dumps(location_stream))

                with open(f"{current_dir}/output/{self.run_id}/{self.current_time_step}.route_stream.json", 'w') as publish_file:
                    publish_file.write(json.dumps(route_stream))


        # Gather history in timewindow as paths for visualization
        if self.sim_settings['PUBLISH_PATHS_HISTORY']:
            if (((self.current_time_step + 1) * self.sim_settings['SIM_STEP_SIZE']) % self.sim_settings['PATHS_HISTORY_TIME_WINDOW'] ) == 0:
                timewindow_end = self.current_time
                timewindow_start = timewindow_end - relativedelta(seconds=self.sim_settings['PATHS_HISTORY_TIME_WINDOW']+self.sim_settings['SIM_STEP_SIZE'])
                logging.info(timewindow_start, timewindow_end)

                paths_history = self.analytics_app.get_history_as_paths(timewindow_start, timewindow_end)
                # print(publish_dict)

                if self.sim_settings['WRITE_PH_OUTPUT_TO_FILE']:
                    current_dir = os.path.dirname(os.path.abspath(__file__))
                    if not os.path.exists(f"{current_dir}/output/{self.run_id}"):
                        os.makedirs(f"{current_dir}/output/{self.run_id}")

                    with open(f"{current_dir}/output/{self.run_id}/{self.current_time_step}.paths_history.json", 'w') as publish_file:
                        publish_file.write(json.dumps(paths_history))


        if self.current_time_step == self.sim_settings['SIM_DURATION']-1:
            self.shutdown()


    # def refresh(self, time_step):
    #     self.prev_time_step = self.current_time_step
    #     # self.current_time_step = self.model.driver_schedule.time
    #     self.current_time_step = time_step
    #     self.elapsed_duration_steps = self.current_time_step - self.prev_time_step

    #     self.current_time = self.reference_time + relativedelta(seconds = time_step * self.sim_settings['SIM_STEP_SIZE'])

