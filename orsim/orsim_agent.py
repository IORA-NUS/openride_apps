from abc import ABC, abstractclassmethod, abstractmethod
import asyncio, json, logging

from datetime import datetime
from apps.messenger_service import Messenger
from config import settings

class ORSimAgent(ABC):

    def __init__(self, unique_id, run_id, reference_time, behavior=None):
        self.unique_id = unique_id
        self.run_id = run_id
        self.reference_time = datetime.strptime(reference_time, '%Y%m%d%H%M%S') # datetime
        self.current_time = self.reference_time


        # Ideally behavior should be read from a datafile/db or in case of simulation, generated by the Model and passed in as attribute
        self.prev_time_step = 0
        self.current_time_step = 0
        self.elapsed_duration_steps = 0

        if behavior is not None:
            self.behavior = behavior
        else:
            self.behavior = self.__class__.load_behavior(unique_id)


        self.agent_credentials = {
            'email': f"{self.run_id}_{unique_id}",
            'password': "secret_password",
        }

        # self.agent_messenger = Messenger(run_id, self.agent_credentials, f"ORSimAgent_{self.unique_id}", self.on_receive_message)
        self.agent_messenger = Messenger(run_id, self.agent_credentials, f"ORSimAgent", self.on_receive_message)

    def on_receive_message(self, client, userdata, message):
        ''' '''
        # print(f'Agent {self.unique_id} received message:', message.payload.decode('utf-8'))
        # # payload = json.loads(message.payload.decode('utf-8'))

        # # if payload.get('action') == 'enter_market':
        # #     self.entering_market(payload.get('time_step'))
        # # elif payload.get('action') == 'step':
        # #     self.step(payload.get('time_step'))
        # # elif payload.get('action') == 'exit_market':
        # #     self.exiting_market()
        try:
            self.process_message(client, userdata, message)

            response_payload = {
                'agent_id': self.unique_id,
                'action': 'completed'
            }
        except Exception as e:
            response_payload = {
                'agent_id': self.unique_id,
                'action': 'error'
            }
            logging.exception(str(e))

        self.agent_messenger.client.publish(f'{self.run_id}/ORSimController', json.dumps(response_payload))

    @classmethod
    def run(cls, specs):
        unique_id = specs[0]
        run_id = specs[1]
        reference_date = specs[2]

        agent = cls(unique_id, run_id, reference_date)
        # for i in range(1, 10):
        #     agent.step(i)

        agent.start_listening()


    @abstractclassmethod
    def load_behavior(cls, unique_id):
        pass


    @abstractmethod
    def process_message(self, client, userdata, message):
        pass


    def start_listening(self):
        async_strategy = 'eventlet'
        if settings['CONCURRENCY_STRATEGY'] == 'ASYNCIO':
            print(f'Agent {self.unique_id} is Listening for Messages')
            loop = asyncio.get_event_loop()
            try:
                loop.run_forever()
            except KeyboardInterrupt:
                pass
            finally:
                loop.close()
        elif settings['CONCURRENCY_STRATEGY'] == 'EVENTLET':
            import eventlet

            def run_forever():
                while True:
                    eventlet.sleep(0.1)

            eventlet.spawn(run_forever)


    def get_current_time_str(self):
        return datetime.strftime(self.current_time, "%a, %d %b %Y %H:%M:%S GMT")
