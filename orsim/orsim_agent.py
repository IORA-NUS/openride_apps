from abc import ABC, abstractclassmethod, abstractmethod
import asyncio, json, logging

from datetime import datetime
from dateutil.relativedelta import relativedelta
from apps.messenger_service import Messenger
from apps.config import settings

class ORSimAgent(ABC):

    def __init__(self, unique_id, run_id, reference_time, behavior=None):
        self.unique_id = unique_id
        self.run_id = run_id
        self.reference_time = datetime.strptime(reference_time, '%Y%m%d%H%M%S') # datetime
        self.current_time = self.reference_time

        # Ideally behavior should be read from a datafile/db or in case of simulation, generated by the Model and passed in as attribute
        self.prev_time_step = 0
        self.current_time_step = 0
        self.elapsed_duration_steps = 0

        self._shutdown = False

        if behavior is not None:
            self.behavior = behavior
        else:
            self.behavior = self.__class__.load_behavior(unique_id)

        self.agent_credentials = {
            'email': f"{self.run_id}_{unique_id}",
            'password': "secret_password",
        }

        # self.agent_messenger = Messenger(run_id, self.agent_credentials, f"ORSimAgent_{self.unique_id}", self.on_receive_message)
        self.agent_messenger = Messenger(run_id, self.agent_credentials, f"ORSimAgent", self.on_receive_message)

    def on_receive_message(self, client, userdata, message):
        ''' '''
        # print(f'Agent {self.unique_id} received message:', message.payload.decode('utf-8'))
        # # payload = json.loads(message.payload.decode('utf-8'))

        # # if payload.get('action') == 'enter_market':
        # #     self.entering_market(payload.get('time_step'))
        # # elif payload.get('action') == 'step':
        # #     self.step(payload.get('time_step'))
        # # elif payload.get('action') == 'exit_market':
        # #     self.exiting_market()
        try:
            # logging.info(f"{message.topic = }")
            if message.topic == f"{self.run_id}/ORSimAgent":
                payload = json.loads(message.payload.decode('utf-8'))

                # if payload.get('action') == 'step':
                #     self.current_time_step = payload['time_step']

                # self.process_message(client, userdata, message)
                self.refresh(payload['time_step'])
                self.process_payload(payload)

                response_payload = {
                    'agent_id': self.unique_id,
                    'time_step': self.current_time_step,
                    'action': 'completed',
                }
            else:
                logging.warning(f'Unprocessed Message: {message.topic = }')
                response_payload = {
                    'agent_id': self.unique_id,
                    'time_step': self.current_time_step,
                    'action': 'unprocessed',
                }
        except Exception as e:
            response_payload = {
                'agent_id': self.unique_id,
                'action': 'error',
                'details': str(e)
            }
            logging.exception(str(e))

        self.agent_messenger.client.publish(f'{self.run_id}/ORSimController', json.dumps(response_payload))

    @classmethod
    def run(cls, specs):
        unique_id = specs[0]
        run_id = specs[1]
        reference_date = specs[2]

        agent = cls(unique_id, run_id, reference_date)
        # for i in range(1, 10):
        #     agent.step(i)

        agent.start_listening()

    @abstractclassmethod
    def load_behavior(cls, unique_id):
        pass

    # @abstractmethod
    # def process_message(self, client, userdata, message):
    #     pass
    @abstractmethod
    def process_payload(self, payload):
        pass

    def start_listening(self):
        async_strategy = 'eventlet'
        if settings['CONCURRENCY_STRATEGY'] == 'ASYNCIO':
            print(f'Agent {self.unique_id} is Listening for Messages')
            loop = asyncio.get_event_loop()
            try:
                loop.run_forever()
            except KeyboardInterrupt:
                pass
            finally:
                loop.close()
        elif settings['CONCURRENCY_STRATEGY'] == 'EVENTLET':
            import eventlet

            def run_forever():
                while True:
                    eventlet.sleep(0.1)
                    if self._shutdown == True:
                        break

            eventlet.spawn(run_forever)

    def get_current_time_str(self):
        return datetime.strftime(self.current_time, "%a, %d %b %Y %H:%M:%S GMT")

    def refresh(self, time_step):

        self.prev_time_step = self.current_time_step
        self.current_time_step = time_step
        self.elapsed_duration_steps = self.current_time_step - self.prev_time_step

        self.current_time = self.reference_time + relativedelta(seconds = time_step * self.sim_settings['SIM_STEP_SIZE'])

    def shutdown(self):
        logging.info(f'Shutting down {self.unique_id = }')
        self._shutdown = True
